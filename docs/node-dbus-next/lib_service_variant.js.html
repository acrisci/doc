<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: lib/service/variant.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: lib/service/variant.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const assert = require('assert');
const parseSignature = require('../signature');

/**
 * @class
 * A class to represent DBus variants for both the client and service
 * interfaces. The {@link ProxyInterface} and [`Interface`]{@link
 * module:interface~Interface} methods, signals, and properties will use this
 * type to represent variant types. The user should use this class directly for
 * sending variants to methods if their signature expects the type to be a
 * variant.
 *
 * @example
 * let str = new Variant('s', 'hello');
 * let num = new Variant('d', 53);
 * let map = new Variant('a{ss}', { foo: 'bar' });
 * let list = new Variant('as', [ 'foo', 'bar' ]);
 */
class Variant {
 /**
  * Construct a new `Variant` with the given signature and value.
  * @param {string} signature - a DBus type signature for the `Variant`.
  * @param {any} value - the value of the `Variant` with type specified by the type signature.
  */
  constructor(signature, value) {
    this.signature = signature;
    this.value = value;
  }
}

function valueIsVariant(value) {
  // used for the marshaller variant type
  return Array.isArray(value) &amp;&amp; value.length === 2 &amp;&amp; Array.isArray(value[0]) &amp;&amp; value[0].length > 0 &amp;&amp; value[0][0].type;
}

function typesEqual(typeA, typeB) {
  if (typeof typeA === 'string') {
    typeA = parseSignature(typeA);
  }
  if (typeof typeB === 'string') {
    typeB = parseSignature(typeB);
  }

  try {
    assert.deepEqual(typeA, typeB);
  } catch (e) {
    return false;
  }

  return true;
}

function collapseSignature(value) {
  if (value.child.length === 0) {
    return value.type;
  }

  let type = value.type;
  for (let i = 0; i &lt; value.child.length; ++i) {
    type += collapseSignature(value.child[i]);
  }
  if (type[0] === '{') {
    type += '}';
  } else if (type[0] === '(') {
    type += ')';
  }
  return type;
}

function parse(variant) {
  // parses a single complete variant
  let type = variant[0][0];
  let value = variant[1][0];

  if (!type.child.length) {
    if (valueIsVariant(value)) {
      return new Variant(collapseSignature(value[0][0]), parse(value));
    } else {
      return value;
    }
  }

  if (type.type === 'a') {
    if (type.child[0].type === '{') {
      // this is an array of dictionary entries
      let result = {};
      for (let i = 0; i &lt; value.length; ++i) {
        // dictionary keys must have basic types
        result[value[i][0]] = parse([[type.child[0].child[1]], [value[i][1]]]);
      }
      return result;
    } else {
      // other arrays only have one type
      let result = [];
      for (let i = 0; i &lt; value.length; ++i) {
        result[i] = parse([[type.child[0]], [value[i]]]);
      }
      return result;
    }
  } else if (type.type === '(') {
    // structs have types equal to the number of children
    let result = [];
    for (let i = 0; i &lt; value.length; ++i) {
      result[i] = parse([[type.child[i]], [value[i]]]);
    }
    return result;
  }
}

function jsToMarshalFmt(signature, value) {
  if (value === undefined) {
    throw new Error(`expected value for signature: ${signature}`);
  }
  if (signature === undefined) {
    throw new Error(`expected signature for value: ${value}`);
  }

  let signatureStr = null;
  if (typeof signature === 'string') {
    signatureStr = signature;
    signature = parseSignature(signature)[0];
  } else {
    signatureStr = collapseSignature(signature);
  }

  if (signature.child.length === 0) {
    if (signature.type === 'v') {
      if (value.constructor !== Variant) {
        throw new Error(`expected a Variant for value (got ${typeof value})`);
      }
      return [ signature.type, jsToMarshalFmt(value.signature, value.value) ];
    } else {
      return [ signature.type, value ];
    }
  }

  if (signature.type === 'a') {
    let result = [];
    if (signature.child[0].type === '{') {
      // this is an array of dictionary elements
      if (value.constructor !== Object) {
        throw new Error(`expecting an object for signature '${signatureStr}' (got ${typeof value})`);
      }
      for (let k of Object.keys(value)) {
        let v = value[k];
        if (v.constructor === Variant) {
          result.push([k, jsToMarshalFmt(v.signature, v.value)]);
        } else {
          result.push([k, jsToMarshalFmt(signature.child[0].child[1], v)[1]]);
        }
      }
    } else {
      if (!Array.isArray(value)) {
        throw new Error(`expecting an array for signature '${signatureStr}' (got ${typeof value})`);
      }
      for (let v of value) {
        if (v.constructor === Variant) {
          result.push(jsToMarshalFmt(v.signature, v.value));
        } else {
          result.push(jsToMarshalFmt(signature.child[0], v)[1]);
        }
      }
    }
    return [ signatureStr, result ];
  } else if (signature.type === '(') {
    if (!Array.isArray(value)) {
      throw new Error(`expecting an array for signature '${signatureStr}' (got ${typeof value})`);
    }
    if (value.length !== signature.child.length) {
      throw new Error(`expecting struct to have ${signature.child.length} members (got ${value.length} members)`);
    }
    let result = [];
    for (let i = 0; i &lt; value.length; ++i) {
      let v = value[i];
      if (signature.child[i] === 'v') {
        if (v.constructor !== Variant) {
          throw new Error(`expected a Variant for struct member ${i+1} (got ${v})`);
        }
        result.push(jsToMarshalFmt(v.signature, v.value));
      } else {
        result.push(jsToMarshalFmt(signature.child[i], v)[1]);;
      }
    }
    return [ signatureStr, result ];
  } else {
    throw new Error(`got unknown complex type: ${signature.type}`);
  }
}

module.exports = {
  parse: parse,
  typesEqual: typesEqual,
  valueIsVariant: valueIsVariant,
  collapseSignature: collapseSignature,
  jsToMarshalFmt: jsToMarshalFmt,
  Variant: Variant
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-interface.html">interface</a></li><li><a href="module-validators.html">validators</a></li></ul><h3>Classes</h3><ul><li><a href="DBusError.html">DBusError</a></li><li><a href="MessageBus.html">MessageBus</a></li><li><a href="module-interface-Interface.html">Interface</a></li><li><a href="module-interface-Name.html">Name</a></li><li><a href="NameExistsError.html">NameExistsError</a></li><li><a href="ProxyInterface.html">ProxyInterface</a></li><li><a href="ProxyObject.html">ProxyObject</a></li><li><a href="Variant.html">Variant</a></li></ul><h3>Global</h3><ul><li><a href="global.html#DBUS_NAME_FLAG_ALLOW_REPLACEMENT">DBUS_NAME_FLAG_ALLOW_REPLACEMENT</a></li><li><a href="global.html#DBUS_NAME_FLAG_DO_NOT_QUEUE">DBUS_NAME_FLAG_DO_NOT_QUEUE</a></li><li><a href="global.html#DBUS_NAME_FLAG_REPLACE_EXISTING">DBUS_NAME_FLAG_REPLACE_EXISTING</a></li><li><a href="global.html#sessionBus">sessionBus</a></li><li><a href="global.html#setBigIntCompat">setBigIntCompat</a></li><li><a href="global.html#systemBus">systemBus</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Thu Apr 04 2019 10:40:15 GMT-0400 (Eastern Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
